## Global libraries, variables, and functions for chabs analysis


######################### libraries #####################

library(phyloseq)
library(ggplot2)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(gridExtra)
library(vegan)
library(cowplot)
library(gtable)
library(pander)
library(tidyr)
library(psych)


####################### global vars #########################

# Set the ggplot theme
theme_set(theme_bw())

# Color palette for stations
station_colors = c("red", "#ffa500", "#0080ff")





######################## global functions ###################


# Function to order date levels correctly, including Aug 11
order_dates_aug11 <- function(df) {
  df$Date <- factor(df$Date, 
                    levels = c("6/16","6/30","7/8","7/14","7/21",
                               "7/29","8/4","8/11","8/18","8/25","9/2","9/8","9/15",
                               "9/23","9/29","10/6","10/15","10/20","10/27"))
  return(df)
}

# Function to order date levels correctly, not including Aug 11
order_dates <- function(df) {
  df$Date <- factor(df$Date,
                    levels = c("6/16","6/30","7/8","7/14","7/21",
                               "7/29","8/4", "8/18","8/25","9/2","9/8","9/15",
                               "9/23","9/29","10/6","10/15","10/20","10/27"))
  return(df)
}

# Function to create a named list
# Args: a vector of strings
#
# Returns: a list with the names supplied in the vector
named_list <- function(...){
  names <- as.list(substitute(list(...)))[-1L]
  result <- list(...)
  names(result) <- names
  result
}

# Scales reads by 
# 1) taking proportions
# 2) multiplying by a given library size of n
# 3) rounding 
# Default for n is the minimum sample size in your library
# Default for round is floor
scale_reads <- function(physeq, n = min(sample_sums(physeq)), round = "floor") {
  
  # transform counts to n
  physeq_scale <- transform_sample_counts(physeq, 
                                          function(x) {(n * x/sum(x))}
  )
  
  # Pick the rounding functions
  if (round == "floor") {
    otu_table(physeq_scale) <- floor(otu_table(physeq_scale))
  } else if (round == "round") {
    otu_table(physeq_scale) <- round(otu_table(physeq_scale))
  }
  
  # Prune taxa and return new phyloseq object
  physeq_scale <- prune_taxa(taxa_sums(physeq_scale) > 0, physeq_scale)
  return(physeq_scale)
}

# function to extract a legend from a ggplot object
grab_legend <- function(a_ggplot) {
  tmp <- ggplot_gtable(ggplot_build(a_ggplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  legend
}

# Function to make a ggplot lineplot of an OTU's relative abundance over time
#
# Args:
#   df: a melted data frame generated by calling psmelt() on a phyloseq object. 
#       Contains an "Abundance" column for the OTU's abundance 
#   otu: the OTU to generate a lineplot for
#   taxrank: the taxonomic rank to appear in the plot title (e.g. "Genus")
# Returns:
#   a ggplot lineplot
plot_otus <- function(df, otu, taxrank) {
  ggplot(df, 
         aes(x = Date, y = Abundance, group = Station, color = Station, shape = Station)) +
    geom_point(size = 2) +
    geom_line(size = 0.7) +
    ggtitle(paste(df[1, taxrank], otu)) +
    ylab("rel. abund") + 
    scale_color_manual(values = station_colors) +
    scale_x_discrete(
      breaks = c("7/8", "8/4", "9/2", "10/6"),
      labels = c("Jul", "Aug", "Sep", "Oct"),
      drop = FALSE
    ) +
    theme(
      axis.title.x = element_blank(),
      axis.title.y = element_text(size = 9),
      plot.title = element_text(size = 10, face = "bold")
    ) 
}



########################## Data loading ##############################

# Import metadata file with nutrients, pigments and toxin
nutrient <- read.csv("../../Data/formatted-data/nutrient_cleaned.csv")

# Format nutrient data
nutrient <- 
  nutrient %>%
  filter(!(Date %in% c("5/27", "6/10", "11/3"))) %>%
  order_dates_aug11() 



load("../../data/formatted-data/erie-data.RData")

## Normalization
# Scale counts to an even depth by dividing by total reads and multiplying by 
# the minimum library size


## Scale reads in OTU table to even depth 
depth = 15000

erie_scale <- 
  erie %>%
  scale_reads(n = depth, round = "round") 



